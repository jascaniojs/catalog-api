import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import { AppModule } from '../src/app.module';
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import { config } from 'dotenv';
import { resolve } from 'path';
import {
  createTestDynamoDBClient,
  cleanupTable,
} from './utils/dynamodb-test.util';
import { loadTestUsers } from './utils/test-users.util';

describe('Catalog Module (e2e)', () => {
  let app: INestApplication;
  let adminToken: string;
  let userToken: string;
  let dynamoClient: DynamoDBDocumentClient;
  let catalogTableName: string;

  beforeAll(async () => {
    // Set NODE_ENV to test to skip AWS Secrets Manager
    process.env.NODE_ENV = 'test';

    // Load environment variables from .env.local (same as development)
    config({ path: resolve(__dirname, '../.env.local') });

    // Use same DynamoDB configuration as development
    catalogTableName = process.env.DYNAMODB_TABLE_NAME || 'catalog-items';

    console.log('[Test Setup] Using catalog table:', catalogTableName);

    // Create DynamoDB client for cleanup (uses same Docker container as development)
    dynamoClient = createTestDynamoDBClient();

    // Load test user tokens from users.json (generated by npm run db:seed)
    const testUsers = loadTestUsers();
    adminToken = testUsers.admin.token;
    userToken = testUsers.user.token;

    console.log('[Test Setup] Loaded admin token:', adminToken.substring(0, 20) + '...');
    console.log('[Test Setup] Loaded user token:', userToken.substring(0, 20) + '...');

    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.setGlobalPrefix('api'); // Set API prefix like in main.ts
    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
      }),
    );

    await app.init();
  });

  afterAll(async () => {
    // Close the NestJS application
    if (app) {
      await app.close();
    }

    // Destroy DynamoDB client to close connections
    if (dynamoClient) {
      dynamoClient.destroy();
    }
  });

  beforeEach(async () => {
    // Clean up catalog items before each test
    await cleanupTable(dynamoClient, catalogTableName);
  });

  describe('POST /api/catalog (Create Item)', () => {
    it('should create a catalog item with valid data', async () => {
      const createDto = {
        title: 'Integration Test Product',
        description:
          'This is a comprehensive description that is longer than sixty characters for quality scoring',
        category: 'Electronics',
        tags: ['test', 'integration', 'e2e'],
      };

      const response = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto)
        .expect(201);

      expect(response.body).toMatchObject({
        title: createDto.title,
        description: createDto.description,
        category: createDto.category,
        tags: createDto.tags,
        status: expect.any(String),
      });
      expect(response.body.id).toBeDefined();
      expect(response.body.qualityScore).toBeDefined();
      expect(response.body.qualityScore.total).toBeGreaterThan(0);
    });




    it('should reject creation without authentication', async () => {
      const createDto = {
        title: 'Test Product',
        description: 'Test description',
        category: 'Test',
        tags: ['test'],
      };

      await request(app.getHttpServer())
        .post('/api/catalog')
        .send(createDto)
        .expect(401);
    });

    it('should validate required fields', async () => {
      const invalidDto = {
        description: 'Missing title',
      };

      await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(invalidDto)
        .expect(400);
    });
  });

  describe('GET /api/catalog (Get All Items)', () => {
    it('should return empty array when no items exist', async () => {
      const response = await request(app.getHttpServer())
        .get('/api/catalog')
        .expect(200);

      expect(response.body).toEqual([]);
    });

    it('should return all catalog items', async () => {
      // Create test items
      const item1 = {
        title: 'Product 1',
        description: 'Description for product 1 that is longer than sixty characters',
        category: 'Category1',
        tags: ['tag1'],
      };

      const item2 = {
        title: 'Product 2',
        description: 'Description for product 2 that is longer than sixty characters',
        category: 'Category2',
        tags: ['tag2'],
      };

      await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(item1);

      await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(item2);

      const response = await request(app.getHttpServer())
        .get('/api/catalog')
        .expect(200);

      expect(response.body).toHaveLength(2);
      expect(response.body[0].title).toBeDefined();
      expect(response.body[1].title).toBeDefined();
    });
  });

  describe('GET /api/catalog/:id (Get Item by ID)', () => {
    it('should return a catalog item by ID', async () => {
      const createDto = {
        title: 'Findable Product',
        description: 'Description for findable product that is longer than sixty characters',
        category: 'Test',
        tags: ['findable'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      const response = await request(app.getHttpServer())
        .get(`/api/catalog/${itemId}`)
        .expect(200);

      expect(response.body.id).toBe(itemId);
      expect(response.body.title).toBe(createDto.title);
    });

    it('should return 404 for non-existent item', async () => {
      await request(app.getHttpServer())
        .get('/api/catalog/non-existent-id')
        .expect(404);
    });
  });


  describe('PUT /api/catalog/:id (Update Item)', () => {
    it('should update a catalog item', async () => {
      const createDto = {
        title: 'Original Title',
        description: 'Original description that is longer than sixty characters for testing',
        category: 'Original',
        tags: ['original'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      const updateDto = {
        title: 'Updated Title',
        description: 'Updated description that is also longer than sixty characters required',
        category: 'Updated',
        tags: ['updated', 'modified'],
      };

      const response = await request(app.getHttpServer())
        .put(`/api/catalog/${itemId}`)
        .set('Authorization', `Bearer ${userToken}`)
        .send(updateDto)
        .expect(200);

      expect(response.body.title).toBe(updateDto.title);
      expect(response.body.description).toBe(updateDto.description);
      expect(response.body.category).toBe(updateDto.category);
      expect(response.body.tags).toEqual(updateDto.tags);
    });

    it('should recalculate quality score on update', async () => {
      const createDto = {
        title: 'Low Quality',
        description: 'Short description here',
        category: 'Test',
        tags: [],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;
      const originalScore = createResponse.body.qualityScore.total;

      const updateDto = {
        title: 'Much Better Quality Title',
        description:
          'This is a much more comprehensive description that exceeds sixty characters',
        category: 'Electronics',
        tags: ['tag1', 'tag2', 'tag3', 'tag4'],
      };

      const response = await request(app.getHttpServer())
        .put(`/api/catalog/${itemId}`)
        .set('Authorization', `Bearer ${userToken}`)
        .send(updateDto)
        .expect(200);

      expect(response.body.qualityScore.total).toBeGreaterThan(originalScore);
    });

    it('should reject update without authentication', async () => {
      await request(app.getHttpServer())
        .put('/api/catalog/some-id')
        .send({ title: 'New Title' })
        .expect(401);
    });
  });

  describe('DELETE /api/catalog/:id (Delete Item - Admin Only)', () => {
    it('should delete a catalog item as admin', async () => {
      const createDto = {
        title: 'To Be Deleted',
        description: 'This item will be deleted in the test and has enough characters',
        category: 'Test',
        tags: ['delete'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      await request(app.getHttpServer())
        .delete(`/api/catalog/${itemId}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(204);

      // Verify item is deleted
      await request(app.getHttpServer())
        .get(`/api/catalog/${itemId}`)
        .expect(404);
    });

    it('should reject delete from non-admin user', async () => {
      const createDto = {
        title: 'Cannot Delete',
        description: 'Regular user cannot delete this item',
        category: 'Test',
        tags: ['protected'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      await request(app.getHttpServer())
        .delete(`/api/catalog/${itemId}`)
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);
    });
  });

  describe('POST /api/catalog/:id/approve (Approve Item - Admin Only)', () => {
    it('should approve item when quality score >= 70', async () => {
      const createDto = {
        title: 'High Quality Product',
        description:
          'This product has excellent quality with a comprehensive description',
        category: 'Electronics',
        tags: ['tag1', 'tag2', 'tag3', 'tag4'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      const response = await request(app.getHttpServer())
        .post(`/api/catalog/${itemId}/approve`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      expect(response.body.status).toBe('APPROVED');
    });

    it('should not approve item when quality score < 70', async () => {
      const createDto = {
        title: 'Low Quality',
        description: 'Short description here',
        category: 'Test',
        tags: [],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      const response = await request(app.getHttpServer())
        .post(`/api/catalog/${itemId}/approve`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(400);

      expect(response.body.message).toContain('low quality score');
    });

    it('should reject approval from non-admin user', async () => {
      const createDto = {
        title: 'High Quality Product',
        description:
          'This product has excellent quality with a comprehensive description',
        category: 'Electronics',
        tags: ['tag1', 'tag2', 'tag3', 'tag4'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      await request(app.getHttpServer())
        .post(`/api/catalog/${itemId}/approve`)
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);
    });
  });

  describe('POST /api/catalog/:id/reject (Reject Item - Admin Only)', () => {
    it('should reject an item', async () => {
      const createDto = {
        title: 'To Be Rejected',
        description: 'This item will be rejected by admin with enough characters here',
        category: 'Test',
        tags: ['reject'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      const response = await request(app.getHttpServer())
        .post(`/api/catalog/${itemId}/reject`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      expect(response.body.status).toBe('REJECTED');
    });

    it('should reject rejection from non-admin user', async () => {
      const createDto = {
        title: 'Test Product',
        description: 'Test description with enough characters for quality scoring purposes',
        category: 'Test',
        tags: ['test'],
      };

      const createResponse = await request(app.getHttpServer())
        .post('/api/catalog')
        .set('Authorization', `Bearer ${userToken}`)
        .send(createDto);

      const itemId = createResponse.body.id;

      await request(app.getHttpServer())
        .post(`/api/catalog/${itemId}/reject`)
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);
    });
  });
});
